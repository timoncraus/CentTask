Решение задачи на C++ и Python. После измерения времени, оказалось, что программа на Python выполняется за 62,5 секунд, а на C++ - за 0,6 секунд (всегда по-разному, но в любом случае выходит во много раз быстрее).


Задача была решена ради интереса и описана в книге "Математические игры с дурацкими рисунками" Орлина Бена. 


Звучит она так:


"Другие головоломки с монетами напрямую связаны с системой выбора номиналов. В США требуется в общей сложности 470 монет,
чтобы оптимальным образом набрать все суммы от 1¢ до 99¢: одна
монета, если вам нужен 1¢, две монеты, чтобы набрать 2¢... и так
далее, вплоть до девяти монет для 99¢. Можно ли уменьшить это
число, изменив номиналы монет, то есть отказавшись от системы 
центникель-дайм-квотер в пользу другого набора из четырех монет?"


"Оказывается можно. Если заменить пятицентовик на трехцентовик
(назовем его «трикель»), то потребуется на 50 монет меньше.
Некоторые необычные комбинации еще лучше (например, 1¢, 4¢, 11¢ и
39¢). Тем не менее я благодарен казначейству США, что оно
отказалось от этих вариантов, иначе каждая покупка шоколадного
батончика приводила бы к остановке мировой экономики.
Хорошая задача для умелого программиста: какой набор четырех
номиналов сводит к минимуму количество монет, требующихся для
набора всех сумм от 1¢ до 99¢?"


Выведем все варианты, дающие в сумме 414 или меньше:

![image](https://github.com/user-attachments/assets/d7de5370-8cb9-45fa-863c-7f16b9d45f4c)


Как видно из результата, встречается строчка, описанная в книге: монеты номиналами 1, 4, 11 и 39 действительно дают 414 в сумме.


Однако, можно еще лучше. Монеты номиналами 1, 3, 11, 37 (38) дают 410 в сумме. Меньше этой суммы набрать не получится.

Важные примечания и моменты, которые я осознал впоследствии!!!
1. Используется жадный алгоритм, который неидеален.

Цитата с википедии: "Для данной задачи жадный алгоритм не всегда даёт оптимальное решение, а только для некоторых, называемых каноническими, монетных систем, вроде используемых в США (1, 5, 10, 25 центов). Неканонические системы таким свойством не обладают. Так, например, сумму в 24 копейки монетами в 1, 5 и 7 коп. жадный алгоритм разменивает так: 7 коп. — 3 шт., 1 коп. — 3 шт., в то время как правильное решение — 7 коп. — 2 шт., 5 коп. — 2 шт."

Другими словами, он неправильно вычисляет результат, но быстро. в книге эта проблема не затрагивалась, поэтому она была проигнорирована.

2. Используется стандартный контейнер list в Python, хотя можно было бы использовать array.array или даже NumPy array, что могло бы существенно ускорить и оптимизировать код.
3. Перебираются все варианты и сравниваются конечные величины, хотя можно было бы рационализировать выборку и уменьшить количество переборов. (например, нет смысла перебирать, когда самая мелкая монета, после монеты 1, больше 10, так как в таком случае становится очевидно, что 1+1+1+1+1+1+1+1+1+1 точно будет невыгодно и будет уступать другим вариантам, в которых вторая самая мелкая монета меньше 10; и т.д., и т.д.)
